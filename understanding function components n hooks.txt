Also refer: https://overreacted.io/how-are-function-components-different-from-classes/

https://overreacted.io/a-complete-guide-to-useeffect/
Takeaway:
Every render has its own snapshot of props, state, useEffect function, everything.

Before we can talk about effects, we need to talk about rendering.
Whenever we update the state, React calls our component. Each render result “sees” its 
own counter state value which is a constant inside our function.

How Function components render/Functions and useState hook:
https://reactjs.org/docs/hooks-state.html#recap
1) Line 1: We import the useState Hook from React. It lets us keep local state in a function component.
2) Line 4: Inside the Example component, we declare a new state variable by calling the useState Hook.
It returns a pair of values, to which we give names. We’re calling our variable 
count because it holds the number of button clicks. We initialize it to zero by passing 
0 as the only useState argument. The second returned item is itself a function. It lets us
 update the count so we’ll name it setCount.
3) Line 9: When the user clicks, we call setCount with a new value. React will then re-render 
the Example component, passing the new count value to it.
This might seem like a lot to take in at first. Don’t rush it! If you’re lost in the 
explanation, look at the code above again and try to read it from top to bottom. 
We promise that once you try to “forget” how state works in classes, and look at 
this code with fresh eyes, it will make sense.

Refer: https://reactjs.org/docs/hooks-faq.html#from-classes-to-hooks
render(): This is the function component body itself.


Class component:
Every time state (using this.setState()) or props are updated, the class component re-renders.
https://reactjs.org/docs/state-and-lifecycle.html#converting-a-function-to-a-class
The render method will be called each time an update happens, but as long as we render
<Clock /> into the same DOM node, only a single instance of the Clock class will be used. 
[G: So the 'this' insdie class refers to same instance till it is unmounted.]
This lets us use additional features such as local state and lifecycle methods. 

How class component re-denders/sequence of events:
https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class
Refer: Let’s quickly recap what’s going on and the order in which the methods are called:...
1) When <Clock /> is passed to ReactDOM.render(), React calls the constructor of the Clock component. 
Since Clock needs to display the current time, it initializes this.state with an object 
including the current time. We will later update this state.
2) React then calls the Clock component’s render() method. This is how React learns what 
should be displayed on the screen. React then updates the DOM to match the Clock’s render output.
3) When the Clock output is inserted in the DOM, React calls the componentDidMount()
 lifecycle method. Inside it, the Clock component asks the browser to set up a timer
 to call the component’s tick() method once a second.
4) Every second the browser calls the tick() method. Inside it, the Clock component 
schedules a UI update by calling setState() with an object containing the current time. 
Thanks to the setState() call, React knows the state has changed, and calls the render() 
method again to learn what should be on the screen. This time, this.state.date in the 
render() method will be different, and so the render output will include the updated time. 
React updates the DOM accordingly.
5) If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() 
lifecycle method so the timer is stopped.
